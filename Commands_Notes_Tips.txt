################## Tips to use Python Netmiko ##################
from netmiko import Netmiko

my_devices_dict = {
    "host": "router_name",
    "username": "User ID",
    "password": "device password"
    "device_type": "cisco_nxos", #Use dir(netmiko) to find supported vendors.
    "global_delay_factor": 5 #Use global_delay_factor to set delay (in second) at the global level.
}

net_connect = Netmiko(**my_devices_dict)
'''Always use ** in front of my_devices_dict so Python will run through all the elements in my_devices_dict dictionary.'''

output = net_connect.send_command("show", expect_string=r"")
'''Use the expect_string argument when the router/device gives a different trailing ouput.'''

output = net_connect.send_command("write mem", delay_factor=5)
'''Use delay_factor in seconds for timing of the commands that take longer than 1 second to run.'''

output = net_connect.send_command_timing("clear ip arp")
'''Use send_command_timing() for commands that require additional user input.'''

output = net_connect.send_command("show ip route", use_textfsm=True)
'''Export the show ip route output to TextFSM template (list). To use TextFSM, (1) Git clone ntc-templates from Github, (2) Make sure the Python program is in the same directory as ntc-templates for it to work. (3) Check ntc-templates index.txt file for supported show commands.'''

output = net_connect.send_config_set(commands)
'''Use send_config_set() to send 1 string command or a list of commands. send_config_set will ouput the commands that you entered.'''

output = net_connect.commit()
'''Use net_connect.commit() after the send_config_set() to save router configuration. Use case fo Juniper, NXOS.'''

output = net_connect.send_config_from_file("commands.txt")
'''Use the commands from the file.'''

import logging
logging.basicConfig(filename="test.log", level=logging.DEBUG)
logger = logging.getLogger("netmiko")
'''Turn on longging to troubleshoot issue from Netmiko. Use .write_channel("show version\n") and .read_channel() as your own operations.'''

################## Jinja2 ##################
Data Structure Workflow: Variables (CSV, text) > Configuration Template > Output Files

import jinja2
'''Import jinja2 module'''

{{variable_name}}
'''Use {{}} to define a variable in Jinja2'''

----------------- Example Code -----------------
bgp_variables = {
    "peer1_ip": "10.255.255.2",
    "peer1_as": 20,
    "advertised_route1": "10.10.200.0/24",
    "advertised_route2": "10.10.201.0/24",
    "advertised_route3": "10.10.202.0/24",
}

bgp_template = """
router bgp 10
 address-family ipv4 unicast
 neighbor {{peer1_ip}} remote-as {{peer1_as}}
 network {{advertised_route1}}
 network {{advertised_route2}}
 network {{advertised_route3}}
"""

t = jinja2.Template(bgp_template)   #<--- bgp_template can be an external Jinja2 file .j2 
t2 = t.render(bgp_variables)        #<--- bgp_variables is a dictionary and can be external CSV or text file
print(t2)
------------------------------------------------

{% for route in advertised_routes %}
network {{route}}
{% endfor %}
'''How to use the for loop in Jinja2. For loop must be in the Jinja2 file (nxos_bgp_template.j2). The {%-} means remove the spacing in front or {-%} remove spacing after, to make the print pretty.'''

----------------- Example Code -----------------
advertised_routes = ["10.10.200.0/24", "10.10.201.0/24", "10.10.202.0/24"] #<--- Variable advertised_routes

bgp_variables = {
    "peer1_ip": "10.255.255.2",
    "peer1_as": 20,
    "advertised_routes" = advertised_routes,    #<--- Assigned value to variable advertised_routes
}

template_file = "nxos_bgp_template.j2"
with open(template_file) as f:
    bgp_template = f.read()

''' print(bgp_template)
router bgp 10
 address-family ipv4 unicast
 neighbor {{peer1_ip}} remote-as {{peer1_as}}
 {%- for route in advertised_routes %}  #<--- Jinja2 for loop through advertised_routes value
 network {{route}}                      #<--- Apply each element from the for loop
 {%- endfor %}                          #<--- End for loop
'''

t = jinja2.Template(bgp_template)
t2 = t.render(bgp_variables)
------------------------------------------------

{% if peer1_ipv6 %}
command
{% elif %}
command
{% else %}
{% endif %}
'''How to use conditionals If/Elif/Else in Jinja2. Make sure "peer1_ipv6" key is a boolen True or False'''

----------------- Example Code -----------------
advertised_routes = ["10.10.200.0/24", "10.10.201.0/24", "10.10.202.0/24"]

bgp_variables = {
    "peer1_ip": "10.255.255.2",
    "peer1_as": 20,
    "peer1_ipv6": True,
    "advertised_routes" = advertised_routes,
}

''' print(bgp_template)
router bgp 10
 address-family ipv4 unicast
 neighbor {{peer1_ip}} remote-as {{peer1_as}}
 {%- for route in advertised_routes %}
 network {{route}}
 {%- endfor %}
 update-source loopback1
 {% if peer1_ipv6 -%}               #<--- Conditional check in bgp_variables for peer1_ipv6 value
 address-family ipv6 unicast        #<--- Execute the operation
 {% endif %}                        #<--- End if statement
'''
------------------------------------------------

{% for router_name, ip_addr in router.items() %}
{{ router_name }} >>> {{ip_addr}}
    {% if ipv4 %}
    address-family ipv4 unicast
    {% end if %}
{% endfor %}
'''You can use Dictionary with nested variables. Jinja2 template allows nested loops'''

----------------- Example Code -----------------
bgp_variables = {
    "routers": {
        "r1": "10.10.10.1",
        "r2": "10.10.10.2",
        "r3": "10.10.10.3",
    },
    "ip_list": [
        "1.1.1.1",
        "10.1.1.1",
        "192.168.1.1"
    ],
    "ipv4": True,
    "ipv6": False,
}

bgp_template = """
{% for router_name, ip_addr in router.items() %}
{{ router_name }} >>> {{ip_addr}}
    {% for ip in ip_list %}
    {{ ip }}
    {% endfor %}
    {% if ipv4 %}
    address-family ipv4 unicast
    {% elif ipv6 %}
    address-family ipv6 multicast
    {% end if %}
{% endfor %}
"""
------------------------------------------------

