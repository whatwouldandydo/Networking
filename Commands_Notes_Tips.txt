################## How to Handle Complex Data Structures ##################
Peeling the data back layer by layer from the outer to the inner.

Is it a List or a Dictionary? Use type() to identify the data type.

List:
    1. Look at the length len() of the list
    2. If len() = 1, just grap the first entry e.i. data_list[0]
    3. If len() is multiple elements, use the for loop with 'break' to see the first entry

Dictionary:
    1. If it's Dictionary nested inside a List, remove the dictionary from inside the list by creating a new variable to get the first element from the list.
        data1 = data_list[0]
    2. Look at the keys()
        print(data1.keys())
    3. Look at each key name to find the information that you wanted
        print(data1["key_name"])
    4. Once you find the information from the key name, create a new variable for that key name
        data2 = data1["key_name"]
    5. When it's a nested dictionary (dictionaries inside a dictionary), repeat Step #2-4 until you find the information you wanted
    6. Create a for loop with dictionary .items()

        for key_name, val_name in data2.items():
            print(key_name)
            print(val_name["nested_key_name"])
            break

################## Tips to use Python Netmiko ##################
ipython -i test.py
'''Use ipython to run the Python file to get interactive mode such as dir(), help(), print() in the code itself.'''

from netmiko import Netmiko
'''From libary netmiko import class Netmiko'''

device_type="cisco_ios"
'''device_type uses Vendor_OS_Transport. Example: "cisco_ios_serial" '''

session_log="router_session_log.txt"
'''Save the device output session log to file name, router_session_log.txt'''

my_devices_dict = {
    "host": "router_name",
    "username": "User ID",
    "password": "device password"
    "device_type": "cisco_nxos", #Use dir(netmiko) to find supported vendors.
    "global_delay_factor": 5, #Use global_delay_factor to set delay (in second) at the global level.
}

net_connect = Netmiko(**my_devices_dict)
'''Always use ** in front of my_devices_dict so Python will run through all the elements in my_devices_dict dictionary.'''

output = net_connect.send_command("show", expect_string=r"")
'''Use the expect_string argument when the router/device gives a different trailing ouput.'''

output = net_connect.send_command("write mem", delay_factor=4, max_loops=1000)
'''Use delay_factor for timing of the commands that take longer than 5 seconds to run. delay_factor=4 means quadrupble the delays. By default send_command/second_command_expect wait for about 90 seconds (delay_factor=1). Do not use delay_factor beyond 10. max_loops is the number of iterations before the method gives out an error (default is 500).'''

output = net_connect.send_command_timing("clear ip arp")
'''Use send_command_timing() for commands that require additional user input such as delete command. send_command_timing will wait for 2 additional seconds once there is no new data available. This is using delay_factor of 1. delay_factor=2 will double this, delay_factor=4 will quadruple.'''

output = net_connect.send_command("show ip route", use_textfsm=True)
'''Export the show ip route output to TextFSM template (list). To use TextFSM, (1) Git clone ntc-templates from Github, (2) Make sure the Python program is in the same directory as ntc-templates for it to work. (3) Check ntc-templates index.txt file for supported show commands.'''

output = net_connect.send_config_set(commands)
'''Use send_config_set() to send 1 string command or a list of commands. send_config_set will ouput the commands that you entered.'''

output = net_connect.send_config_from_file(config_file="commands.txt")
'''Use the commands from the file.'''

output = net_connect.commit()
save_cfg = net_connect.save_config()
'''Use save_config() after the send_config_set() to save router configuration. Use commit() for Juniper, NXOS.'''

import logging
logging.basicConfig(filename="test.log", level=logging.DEBUG)
logger = logging.getLogger("netmiko")
'''Turn on longging to troubleshoot issue from Netmiko. Use .write_channel("show version\n") and .read_channel() as your own operations.'''

export NET_TEXTFSM=/path/ntc-templates/templates
"""TextFSM put the network devices' output to structured data such as list, dictionary, etc ... By default TextFSM look for the /templates/index file in /home directory. Use export NET_TEXTFSM when the ntc-templates directory is different. If TextFSM cannot correlate the template, it returns the ouput to string."""

output = net_connect.send_command("show ip int brie", use_textfsm=True)
"""Use TextFSM as structured data for the 'show ip int brie' output."""

transfer_dict = netmiko.file_transfer(
    net_connect, #Your SSH connect to the network device
    source_file="test1.txt",
    dest_file="test2.txt", #You can rename the file at the destination
    direction="put", # "get"
    overwrite_file=True
)
"""You can use file_transfer for SCP (Secure Copy). If the destination file already existed and MD5 hash matches, file_transfer won't run. Limited supported for vendor. May not work with large file such as images."""

device1 = {
    "host": "cisco1",
    "device_type": "cisco_ios",
    "username": username,
    "use_keys": True, # Use SSH or RSA key for the user
    "key_file": "/path/test_rsa" #Location of the key
}
"""You can use SSH or RSA keys for user authentication."""

################## Jinja2 ##################
Data Structure Workflow: Variables (CSV, text) > Configuration Template > Output Files

import jinja2
'''Import jinja2 module'''

{{variable_name}}
'''Use {{}} to define a variable in Jinja2'''

----------------- Example Code -----------------
bgp_variables = {
    "peer1_ip": "10.255.255.2",
    "peer1_as": 20,
    "advertised_route1": "10.10.200.0/24",
    "advertised_route2": "10.10.201.0/24",
    "advertised_route3": "10.10.202.0/24",
}

bgp_template = """
router bgp 10
 address-family ipv4 unicast
 neighbor {{peer1_ip}} remote-as {{peer1_as}}
 network {{advertised_route1}}
 network {{advertised_route2}}
 network {{advertised_route3}}
"""

t = jinja2.Template(bgp_template)   #<--- bgp_template can be an external Jinja2 file .j2 
t2 = t.render(bgp_variables)        #<--- bgp_variables is a dictionary and can be external CSV or text file
print(t2)
------------------------------------------------

{% for route in advertised_routes %}
network {{route}}
{% endfor %}
'''How to use the for loop in Jinja2. For loop must be in the Jinja2 file (nxos_bgp_template.j2). The {%-} means remove the spacing in front or {-%} remove spacing after, to make the print pretty.'''

----------------- Example Code -----------------
advertised_routes = ["10.10.200.0/24", "10.10.201.0/24", "10.10.202.0/24"] #<--- Variable advertised_routes

bgp_variables = {
    "peer1_ip": "10.255.255.2",
    "peer1_as": 20,
    "advertised_routes" = advertised_routes,    #<--- Assigned value to variable advertised_routes
}

template_file = "nxos_bgp_template.j2"
with open(template_file) as f:
    bgp_template = f.read()

''' print(bgp_template)
router bgp 10
 address-family ipv4 unicast
 neighbor {{peer1_ip}} remote-as {{peer1_as}}
 {%- for route in advertised_routes %}  #<--- Jinja2 for loop through advertised_routes value
 network {{route}}                      #<--- Apply each element from the for loop
 {%- endfor %}                          #<--- End for loop
'''

t = jinja2.Template(bgp_template)
t2 = t.render(bgp_variables)
------------------------------------------------

{% if peer1_ipv6 %}
command
{% elif %}
command
{% else %}
{% endif %}
'''How to use conditionals If/Elif/Else in Jinja2. Make sure "peer1_ipv6" key is a boolen True or False'''

----------------- Example Code -----------------
advertised_routes = ["10.10.200.0/24", "10.10.201.0/24", "10.10.202.0/24"]

bgp_variables = {
    "peer1_ip": "10.255.255.2",
    "peer1_as": 20,
    "peer1_ipv6": True,
    "advertised_routes" = advertised_routes,
}

''' print(bgp_template)
router bgp 10
 address-family ipv4 unicast
 neighbor {{peer1_ip}} remote-as {{peer1_as}}
 {%- for route in advertised_routes %}
 network {{route}}
 {%- endfor %}
 update-source loopback1
 {% if peer1_ipv6 -%}               #<--- Conditional check in bgp_variables for peer1_ipv6 value
 address-family ipv6 unicast        #<--- Execute the operation
 {% endif %}                        #<--- End if statement
'''
------------------------------------------------

{% for router_name, ip_addr in router.items() %}
{{ router_name }} >>> {{ip_addr}}
    {% if ipv4 %}
    address-family ipv4 unicast
    {% end if %}
{% endfor %}
'''You can use Dictionary with nested variables. Jinja2 template allows nested loops'''

----------------- Example Code -----------------
bgp_variables = {
    "routers": {
        "r1": "10.10.10.1",
        "r2": "10.10.10.2",
        "r3": "10.10.10.3",
    },
    "ip_list": [
        "1.1.1.1",
        "10.1.1.1",
        "192.168.1.1"
    ],
    "ipv4": True,
    "ipv6": False,
}

bgp_template = """
{% for router_name, ip_addr in router.items() %}
{{ router_name }} >>> {{ip_addr}}
    {% for ip in ip_list %}
    {{ ip }}
    {% endfor %}
    {% if ipv4 %}
    address-family ipv4 unicast
    {% elif ipv6 %}
    address-family ipv6 multicast
    {% end if %}
{% endfor %}
"""
------------------------------------------------

################## YAML ##################
YAML file (.yml) starts with ---

---
- 1.1.1.1
- 2.2.2.2
- 3.3.3.3
'''This YAML file will return a List in Python and each element in the list is a String.'''

---
router1: 1.1.1.1
router2: 2.2.2.2
router3: 3.3.3.3
router4: "No longer {}"
router5: on
router6: off
router7: True
router8: true
router9: False
router10: yes
router11: 100
'''This YAML file will return a Dictionary in Python. Each Key and Value in the dictionary is a String. Use " when you have special characters. on, off, True, true, False, yes, no are boolen. router11 will return as an Integer.'''

---
rtr1:
  ip_addr: 10.1.1.1
  username: admin
  password: user input
  device_type: cisco_ios
  routing:
    - Static
    - OSPF
    - BGP
rtr2:
  ip_addr: 10.1.1.2
  username: admin
  password: user input
  device_type: juniper_junos
'''Nested dictionary in YAML. rtr1's key routing will return a nested list.'''

filename = "output.yml"
with open(filename, "w") as f:
    output1 = yaml.dump(from_py_dict, f)
    output2 = yaml.dump(from_py_dict, f, default_flow_style=False)
    output3 = yaml.dump(from_py_dict, f, default_flow_style=True)
'''output1 will write to output.yml file as compress form. output2 will write as regular YAML format (easier to read). output3 will write as compress file like you would see in Python.'''

################## JSON ##################
json.dumps(dict, indent)
'''dumps method convert a Python object into a JSON string.'''

json.dump(dict, file_pointer, indent)
'''dump method uses for writing to a JSON file'''

json.load() vs json.loads()
'''The s stands for string meaning the load the file contents as string.'''

Don't put comma , at the end of the JSON or it will generate error

################## CiscoConfParse ##################
from ciscoconfparse import CiscoConfParse
'''From libary ciscoconfparse import class CiscoConfParse'''

cisco_obj = CiscoConfParse("cisco1.txt")
cisco_obj = cisco_obj.splitlines()
'''Must convert the cisco1.txt from string to list datastructure for CiscoConfParse to read. Use splitlines() to convert string into list.'''

cisco_obj.find_objects(r"^interface")
'''Find anything begining a line with interface.'''

cisco_obj.text
'''Look at the text of cisco_obj variable.'''

cisco_obj.children
'''Look at the childrend of cisco_obj variable.'''

cisco_obj.is_parent #Check if the cisco_obj is a is_parent
cisco_obj.is_child  #Check if the cisco_obj is a children
cisco_obj.siblings  #Check if the cisco_obj has any other objects

match = cisco_obj.find_objects(r"^crypto map CRYPTO")
match.re_search_children(r"set transform-set ")
match2 = match[0].text
'''Use re_search_children to search for objects inside the parent. Match2 is to view the data as clear text.'''

dir(CiscoConfParse)
"""Use dir() to view options for finding object such as find_objects(), find_objects_w_child(), etc..."""

help(CiscoConfParse.find_objects_w_child())
"""To see example commands and help options.""""

################## Using Pip ##################
pip list
pip3 list
"""List all the packages that you installed."""

pip freeze > requirements.txt
pip3 freeze > requirements.txt
"""Very useful when recreating an environment by exporting all the installed packages to a file."""

pip install -r requirements.txt
pip3 install -r requirements.txt
"""Install the pacages from the requirements.txt file."""

################## Using Python sys.path ##################
To find out where the Python libaries are imported from.

import sys
from pprint import pprint
pprint(sys.path)
"""Use pprint(sys.path) to view all the paths Python is going to search."""

import re
print(re.__file__)
"""Use print(.__file__) to find which directory the re libary is used.""""

env | grep PYTHON
"""To view the current Python path (PYTHONPATH)."""

export PYTHONPATH=/home/newpath
"""How to set a new python path to /home/newpath."""
